(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[823],{9248:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/line-sweep",function(){return n(1897)}])},9997:function(e,t,n){"use strict";var i=n(5893),s=n(7294),o=n(63),r=n(5697),a=n.n(r);function l(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function c(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function h(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function u(e){return u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},u(e)}function d(e,t){return!t||"object"!==g(t)&&"function"!==typeof t?l(e):t}function m(e,t){return m=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},m(e,t)}function f(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}var g=function(e){return e&&"undefined"!==typeof Symbol&&e.constructor===Symbol?"symbol":typeof e};function b(e){var t=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,i=u(e);if(t){var s=u(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return d(this,n)}}function x(){var e=f(["\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%,-50%);\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: rgba(0,0,0,0.7);\n"]);return x=function(){return e},e}function y(){var e=f(["\n  max-width: ",";\n  max-height: ",";;\n  border-radius: 3px;\n  cursor: pointer;\n  z-index: 3;\n"]);return y=function(){return e},e}function w(){var e=f(["\n  max-width: calc(100% - 24px);\n  max-height: calc(100% - 24px);\n"]);return w=function(){return e},e}var j=o.ZP.div(x()),v=o.ZP.img(y(),(function(e){return e.thumbMxWidth?e.thumbMxWidth:"128px"}),(function(e){return e.thumbMxHeight?e.thumbMxHeight:"128px"})),_=o.ZP.img(w()),S=function(e){!function(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&m(e,t)}(r,e);var t,n,s,o=b(r);function r(){var e;return c(this,r),p(l(e=o.apply(this,arguments)),"state",{isOpen:!1}),p(l(e),"handleShowDialog",(function(){e.setState({isOpen:!e.state.isOpen})})),e}return t=r,(n=[{key:"render",value:function(){var e=this.props,t=e.imgUrl,n=e.alt,s=e.style,o=(void 0===s?{}:s).thumbnail,r=void 0===o?{}:o,a=r.maxWidth,l=r.maxHeight,c=this.state.isOpen;return(0,i.jsxs)("div",{children:[(0,i.jsx)(v,{src:t,onClick:this.handleShowDialog,alt:n,thumbMxWidth:a,thumbMxHeight:l}),c&&(0,i.jsx)(j,{open:!0,onClick:this.handleShowDialog,children:(0,i.jsx)(_,{src:t,onClick:function(e){e.stopPropagation()},alt:n})})]})}}])&&h(t.prototype,n),s&&h(t,s),r}(s.Component);S.propTypes={imgUrl:a().string.isRequired,alt:a().string,style:a().shape({})},S.defaultProps={alt:"",style:{}},t.Z=S},1897:function(e,t,n){"use strict";n.r(t);var i=n(5893),s=(n(7294),n(63)),o=n(5225),r=n(5711),a=n(9832),l=n(6741),c=n(7354),h=n(9997);function p(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}function u(){var e=p(["\n  white-space: pre-wrap;\n"]);return u=function(){return e},e}function d(){var e=p(["\n  display: flex;\n  justify-content: center;\n"]);return d=function(){return e},e}function m(){var e=p(["\n  padding-left: 4px;\n"]);return m=function(){return e},e}var f=s.ZP.div(u()),g=(s.ZP.div(d()),s.ZP.li(m()));t.default=function(){return(0,i.jsx)(o.Z,{children:(0,i.jsx)(r.PU,{children:(0,i.jsxs)(a.XF,{children:[(0,i.jsx)(l.Z,{title:"Solving schedule collisions with geometric algorithms"}),(0,i.jsx)(a.Z0,{}),(0,i.jsx)(a.U7,{children:"Introduction"}),(0,i.jsxs)(f,{children:["Imagine you're given 100,000 points scattered across a plane. Your task seems simple: find the closest pair of points. The naive approach would compare every possible pair, resulting in nearly 5 billion comparisons. But what if I told you there's a technique that could solve this in almost linear time?",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"This elegant approach\u2014the line sweep algorithm\u2014turned out to be the solution to a seemingly unrelated problem I encountered years later. Let me share how this geometric algorithm became the unexpected hero in my event scheduling system."]}),(0,i.jsx)(a.Z0,{}),(0,i.jsx)(a.U7,{children:"How I Discovered Line Sweep: A Scheduling Analysis Dilemma"}),(0,i.jsxs)(f,{children:["The problem was deceptively simple: find all overlapping time slots across thousands of appointments in our scheduling system. My first instinct was the brute-force route\u2014compare every pair of slots and check for collisions. Whether done in SQL or in memory, the approach quickly crumbled under real-world scale. With tens of thousands of slots being logged daily across multiple time zones, the computation became unmanageable.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"I wasn't willing to settle for batching, it felt like conceding defeat. That's when a distant memory resurfaced: the line sweep.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),'If you imagine every appointment as a start and end point on a 1D timeline, the collision problem transforms into something strikingly geometric. By "sweeping" through the sorted list of start and end times, you can track how many appointments are active at any moment\u2014and spot overlaps efficiently.',(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"What once felt like a messy data problem suddenly had a clean, elegant algorithmic core. The line sweep turned out to be the key, transforming our slow and clunky analytics into something snappy."]}),(0,i.jsx)(a.Z0,{}),(0,i.jsx)(a.U7,{children:"Understanding Line Sweep"}),(0,i.jsxs)(f,{children:["At its core, the line sweep algorithm works by imagining an invisible line (usually vertical) that sweeps across the plane from left to right, stopping at important points. Rather than considering all geometric objects simultaneously, we only focus on the objects that intersect with our sweeping line at any given moment.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Think of it like scanning a room with a laser beam\u2014instead of trying to process everything at once, you examine only what the beam illuminates as it moves across the space. This approach dramatically reduces the computational complexity.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(h.Z,{imgUrl:"/static/images/line_sweep_algorithm.png"}),(0,i.jsx)("br",{}),"The key components of any line sweep algorithm include:",(0,i.jsxs)("ol",{children:[(0,i.jsxs)(g,{children:[(0,i.jsx)("strong",{children:"The Sweep Line:"})," A conceptual line that moves across the plane"]}),(0,i.jsxs)(g,{children:[(0,i.jsx)("strong",{children:"Events:"})," Points where we need to update our data structures (like when the sweep line hits a new point)"]}),(0,i.jsxs)(g,{children:[(0,i.jsx)("strong",{children:"Status Structure:"})," A data structure that maintains information about objects currently intersecting the sweep line"]})]})]}),(0,i.jsx)(a.U7,{children:"Solving the Closest Pair Problem"}),(0,i.jsxs)(f,{children:["Let's apply the line sweep technique to find the closest pair of points among n points in a plane\u2014a problem that would normally require O(n\xb2) comparisons.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"The algorithm works as follows:",(0,i.jsxs)("ol",{children:[(0,i.jsx)(g,{children:"Sort all points by their x-coordinates (taking O(n log n) time)"}),(0,i.jsx)(g,{children:"Initialize a variable \u03b4 to track the minimum distance found so far (set to infinity initially)"}),(0,i.jsx)(g,{children:"Create an empty balanced binary search tree (BST) to store points sorted by their y-coordinates"}),(0,i.jsx)(g,{children:"Sweep a vertical line from left to right, processing each point"})]}),(0,i.jsx)("br",{}),"As we process each point p:",(0,i.jsxs)("ol",{children:[(0,i.jsx)(g,{children:"Remove all points from our BST that have x-coordinates less than (p.x - \u03b4), as they cannot form the closest pair with p"}),(0,i.jsx)(g,{children:"Search the BST for all points with y-coordinates between (p.y - \u03b4) and (p.y + \u03b4), as only these points could potentially be closer than our current minimum"}),(0,i.jsx)(g,{children:"Calculate the distance between p and each potential candidate, updating \u03b4 if we find a smaller distance"}),(0,i.jsx)(g,{children:"Insert p into the BST"})]}),(0,i.jsx)("br",{}),(0,i.jsx)(h.Z,{imgUrl:"/static/images/closest_pair.png"}),(0,i.jsx)("br",{}),"The brilliance of this approach is that we don't need to compare every pair of points. At each step, we only consider points within a narrow vertical strip of width 2\u03b4 around our current point. And within this strip, we only look at points within a distance \u03b4 above or below our current point.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"A key insight: within any strip of width \u03b4, there can be at most a constant number of points that are at least \u03b4 apart from each other. This means each point is compared with only a constant number of other points, resulting in an O(n log n) algorithm overall."]}),(0,i.jsx)(a.U7,{children:"Translating Line Sweep to Time: Solving the Collision Problem"}),(0,i.jsxs)(f,{children:["The breakthrough moment came when I realized that time intervals could be treated just like geometric objects. An event with start and end times is conceptually similar to a line segment with start and end points. The collision detection problem in my scheduling system was fundamentally a line segment intersection problem\u2014just along a one-dimensional timeline rather than in 2D space.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Here's how I implemented the solution:",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),'1. Transform events into time points: Each event generates two time points\u2014a start point (adding 1 to our "active count") and an end point (subtracting 1)',(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(c.pP,{children:"-- Start points (value = 1)\nSELECT start_time AS time_point, 1 AS event_value, id, user_id\nFROM appointments \nWHERE date = '2025-05-18'\nUNION ALL\n\n-- End points (value = -1)\nSELECT end_time AS time_point, -1 AS event_value, id, user_id\nFROM appointments \nWHERE date = '2025-05-18'"}),(0,i.jsx)("br",{}),'2. Sort these time points chronologically: This is our "sweep line" moving through time',(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(c.pP,{children:"SELECT \n    time_point,\n    id,\n    user_id,\n    event_value,\n    -- Running sum tracks active events at each moment\n    SUM(event_value) OVER (ORDER BY time_point) AS active_count\nFROM sweep_events\nORDER BY time_point"}),(0,i.jsx)("br",{}),"3. Detect collisions: Wherever the active count exceeds 1, we have overlapping events",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(c.pP,{children:"-- Finding user-specific conflicts\nSELECT \n    s1.id AS slot1_id,\n    s2.id AS slot2_id,\n    s1.user_id,\n    s1.time_point AS collision_point\nFROM sweep_state s1\nJOIN sweep_state s2 ON \n    s1.time_point = s2.time_point AND\n    s1.id < s2.id AND\n    s1.user_id = s2.user_id AND\n    s1.event_value = 1\nWHERE \n    s1.active_count > 1"}),(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"The beauty of this solution is its efficiency. Instead of comparing every possible pair of appointments (n\xb2), we process just 2n time points (start and end for each appointment) in sorted order. The time complexity drops to O(n log n), again dominated by the sorting step."]}),(0,i.jsx)(a.U7,{children:"Beyond Basic Collision Detection"}),(0,i.jsxs)(f,{children:["Once I had the foundation in place, I could extend the solution to handle more complex business rules:",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsxs)("ul",{children:[(0,i.jsx)(g,{children:"User-specific conflicts: Finding cases where the same person is double-booked"}),(0,i.jsx)(g,{children:"Room-specific conflicts: Identifying overlapping bookings for the same physical space"}),(0,i.jsx)(g,{children:"Resource utilization: Determining peak times when we need additional staff"}),(0,i.jsx)(g,{children:"Capacity planning: Visualizing time periods with the highest booking density"})]}),(0,i.jsx)("br",{}),"By adding a few additional dimensions to our sweep, we could answer complex questions that would have been computationally expensive with traditional approaches."]}),(0,i.jsx)(a.U7,{children:"The Elegant Transformation"}),(0,i.jsxs)(f,{children:["What fascinates me most about this algorithm is how elegantly it transforms dimensions. In the closest pair problem, it reduces a two-dimensional search space to a manageable one-dimensional sweep. In my scheduling problem, it transformed a complex temporal relationship question into a simple counting exercise along a timeline.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"This dimensional reduction is what gives the line sweep algorithm its power across seemingly unrelated domains. Whether you're working with points in a plane or events in time, the core principle remains the same: sweep through one dimension in order, maintaining only the information needed at each step.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Sometimes great solutions come from unexpected places\u2014in my case, from a computational geometry algorithm I'd studied years earlier. It's a reminder that algorithmic thinking transcends specific domains, and elegant solutions often have surprising applications."]})]})})})}}},function(e){e.O(0,[115,37,774,888,179],(function(){return t=9248,e(e.s=t);var t}));var t=e.O();_N_E=t}]);